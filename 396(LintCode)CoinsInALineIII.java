/*396. Coins In A Line III
Hard: 
题意: 给定一个序列a[0], a[1],...,a[N-1]
两个玩家Alice和Bob轮流取数
每个人每次只能取第一个数或者最后一个数
双方都运用最优策略，使得自己的的数字和尽量比对手的大
问:先手是否必胜(如果数字和一样，也算先手胜)

例子: 
输入: [1,5,233,7]
True(先手取走1，无论后手取哪个，先手都可以取走233)
*/

/*解题思路
这道题目是根据九章算术DP章节学习到的，有任何疑惑可以参考九章视频。第五课 一小时二十分钟
这道题目我们反过来推倒，从最后一步往前推。对于玩家A和玩家B来说，最后获得的
那一个数的数值可能是数组A中的任意一个。我们就用类似于滑动窗口的办法，从剩余一个数，
往前推，到剩余两个数时最大取值，再到剩余三个数时的最大取值，知道最后从0-(n-1)总共
剩余n个数的取值，看是正数还是负数。
我们用dp不方便存储A和B两个玩家每个玩家在当前数组断的和，所以我们用了一个比较巧妙地办法。
假设最后A玩家取得的数字和是sumA, B玩家取得的数字和是sumB, 只要sumA-sumB > 0就说明A玩家取得的数字和比较大，所以每一次我们就比较 A[i, j]之间，是取A[i]还是A[j]，如果是取A[i]的话，那么我们就要减去dp[i+1][j]这一段之间产生的最大值，这一段的最大值指的是下一次后手可以取的最大值。反之
如果取另一个端点A[j]的话，和下一次在dp[i][j-1]范围内取得的最大值相减。两者之间取较大的那一个。
这个思维很巧妙。
*/
public Solution{
	public boolean firstWillWin(int[] A){

		int n = A.length;
		int[][] dp = new int[n][n];

		for(i=0; i< n; i++) dp[i][i] = A[i];

		for(int len=2; len<=n; len++){
			for(int i =0; i<=n-len; i++){
				int j = i+len-1;
				dp[i][j] = Math.max(A[i]-dp[i+1][j], A[j]-dp[j][j-1]);
			}
		}

		return dp[0][n-1];
	}
}
